## 구현 간에 고민했던 점

### 기능 구현 목록 작성을 익숙하게

1주차에서 힘들었던 점 중에 하나는 개발을 시작하기도 전에 기능 구현 목록을 작성해야하는 것이었습니다. 저는 이전까지 항상 개발을 진행하면서 기능을 구상했었는데요. 이 때문에 구현 목록을 어떻게 작성해야할 지도 감이 잘 안 왔고, 모든 기능을 빠짐없이 작성해야 한다는 강박 때문에 고민이 많았습니다.

미션을 진행하면서 든 생각은, **초기 기능은 최대한 세밀하게 설계**하되, 어차피 코드는 변경될 운명이기 때문에 그때그때 **상황에 맞춰서 빠르게 문서를 수정**해야겠다는 것입니다. 이러한 생각을 통해, 저는 기능 구현 목록 작성에 대한 부담을 조금이나마 떨칠 수 있었습니다.


### 일급 컬렉션과 원시값 포장의 적용

사실 일급 컬렉션이라는 개념은 1주차에서 처음 알게 되었는데, 굳이 이걸 적용해야 하는지에 대한 의문이 있었습니다. 그런데 미션을 진행하면서 객체지향적 코드에 대해 자세히 공부하다보니, 그 의도가 일급 컬렉션과 일맥상통한다는 것을 알게 되었습니다.

저도 정확한 개념까지는 아직 잘 모르겠습니다만, 객체지향에서는 **객체의 내부 정보가 외부로 나가는 것을 기피**하며, 같은 맥락으로 **외부에서 객체가 수정되는 것 또한 싫어**한다고 느꼈습니다. 이러한 관점을 따라간다고 할 때, 일급 컬렉션은 굉장히 좋은 솔루션이고, 원시값 포장 또한 마찬가지입니다.

```
public class Race {

    private List<Car> cars;
    
    public Race(List<Car> cars) {
        CarNameValidator.validateDuplicateForList(cars);
        this.cars = Collections.unmodifiableList(cars);
    }
}
```

저는 위과 같은 형태로 일급 컬렉션을 구현하였습니다. 생성 시점에서 입력값을 검증한 뒤, `Collections.unmodifiableList()` 문법을 이용하여 읽기 전용의 리스트를 생성하는 방식입니다.

```
public class Car {

    private Name name;

    private int distance = 0;
}
```
다음으로는 Car 클래스의 이름 관련 변수인 name에 원시값 포장을 적용했습니다. String 타입으로 선언해도 됐지만, **별도의 검증 로직을 분리할 수 있도록 포장**하였습니다. distance 변수의 경우, 이동 거리에 대한 별도의 검증이 필요하지 않았기 때문에 따로 포장하지 않았습니다.

### getter 없이 구현하기

지난 미션에서 getter를 남발했다가 리팩토링 과정에서 거의 코드를 갈아엎으면서 큰 후회를 했는데요. 이런 이유로 이번 미션에서는 getter를 단 하나도 안 쓰고 예쁘게 구현해보겠다고 다짐했습니다.

다른 부분에서는 정상적으로 getter를 잘 제거했습니다만, 일급 컬렉션인 Race 클래스의 비즈니스 로직을 짜면서부터 문제가 시작되었습니다. 자동차 리스트를 대상으로 `stream` 문법을 사용하여 최댓값을 구하려고 했는데, getter가 없으니 각 자동차의 이동거리를 불러올 수 없었습니다.

그렇다고 이동거리 비교 로직을 Car 클래스 내부에 작성하자니 시간 복잡도가 크게 증가하였고, 저는 `getter를 안 썼지만 복잡한 코드`와 `getter는 썼지만 간결한 코드` 중에서 후자를 선택하게 되었습니다. 다만, getter를 사용했다 하더라도, **비슷한 역할을 하는 객체들 간의 상호작용이었기 때문에 캡슐화를 크게 해치지 않는다고 생각**했습니다.

추가로 Race 객체를 Controller 계층에서 조회할 일이 있었는데, 이 경우에는 `List<Car> cars` 변수가 리스트이기에 수정될 여지가 있었으므로 `Collections.unmodifiableList()` 문법을 사용하여 불변 리스트를 반환하도록 했습니다.


### 첫 테스트 코드 작성

테스트 코드같은 경우는 이번 미션에서 거의 처음으로 작성해보았기 때문에 사실은 정말 부실하고, 다른 분들의  피드백이 필요한 부분이라고 생각합니다. 물론 테스트가 안 돌아가고 이런 건 아니지만, 제가 생각하기엔 다음 3가지 정도의 문제가 있습니다.

먼저 첫째로는 해당 기능이 정말 정상적으로 구현되었는지 테스트하기에는 **테스트 케이스가 많지 않습니다.** 거의 기능당 하나밖에 케이스가 없기 때문에 여러 예외상황이 있지 않을까 싶습니다. 이 부분은 계속해서 보강할 생각입니다.

두 번째로는 **테스트 네이밍이 명확하지 않습니다.** 테스트 메소드명에도 다양한 컨벤션들이 있는데, 공통적으로 테스트의 필요 조건과 그에 따른 실행 결과 등을 포함하는 것으로 알고 있습니다. 다른 분들은 대체적으로 어떤 컨벤션을 자주 쓰시는지 찾아보면서 공부해보려고 합니다.

세 번째로는 **JUnit5에 대한 숙련도 자체가 부족**하다는 점입니다. 어떤 메소드를 적재적소에 활용해야 하는지 잘 감이 오지 않아서 웬만한 테스트는 `assertThat().isEqualTo()`와 `assertThatThrownBy()` 문법을 사용하게 되었는데, 이 부분에 대해서도 더 능숙하게 활용할 수 있도록 알아보고 싶습니다.


## 결론

결론적으로 이번 2주차는, 1주차에서 부족했던 객체지향적 개념들을 채우고 어느정도 숙련도있게 적용할 수 있는 시간이었습니다. 하지만 나아가서, 그래서 정말 좋은 코드와 구조라는 것은 무엇인지에 대한 더 깊은 고민이 생기는 시간이었고, 추가적으로 테스트 코드 공부에 대한 필요성 역시 절실히 느낄 수 있었던 것 같습니다.

3주차 미션을 시작하기 전까지 **최대한 많은 분들과 교류하면서 피드백을 적용**해보고자 합니다. 3주차도 파이팅입니다 🔥
