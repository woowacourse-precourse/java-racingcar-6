## 기능 구현 목록

- 플레이어를 생성하는 기능 [Player]
    - [x] 이름 리스트를 받아서 Player 객체를 생성한다.
    - [ ] PlayerName, (미정) isWinner를 필드로 갖는다.
- 플레이어 이동현황을 생성하는 기능 [PlayerMove]
    - [x] Player를 받아서 PlayerMove 객체를 생성한다.

- 랜덤 숫자를 생성하는 기능 [RandomNumberGenerator]
    - [x] 랜덤 숫자를 뽑는다.
        - 컨트롤러에서 객체를 생성해서 전진 여부 객체 생성 때 넣어주기
        - (그냥 안에서 생성하면 테스트가 어려워진다.)
- 이동 여부를 배정하는 기능 [MoveFactory]
    - [x] 랜덤 숫자가 4이상인지 판단한다.
    - [x] 위의 뽑힌 랜덤 숫자에 의해 이동 여부를 반환한다.

- 게임을 진행한다. [RacingGame]
    - [x] 게임을 초기화 한다: 플레이어별 이동현황을 초기화하고 게임 상태를 진행으로 바꾼다.
    - 플레이어별 이동하는 기능
        - [x] 모든 플레이어에게 이동 여부를 배정한다.
        - [x] 배정받은 이동 여부에 따라 이동한다.
        - [x] 이동을 거리에 반영한다.
        - [ ] 한 이동당 한 번씩 이동결과를 출력한다.

- 게임 승리 판단
    - [ ] 입력한 시도 횟수와 이동 결과 횟수가 같으면 우승자가 된다.
    - [ ] 게임 상태를 종료로 바꾼다.

# 필요한 객체들과 메소드를 생각해보자(추후 삭제)

- Game
- Game에는 List<PlayerMove> 가 있고 GameStatus가 있어야할듯
    - List<PlayerMove>는 일급컬렉션화 하지 않아도 될까?
    - [x] game.init
        - player를 갖고 PlayerMove를 생성해야할듯
        - 아니면 컨트롤러에서 PlayerMove를 생성해서 갖고와야하려나, 테스트를 위해
        - 어쨌든 여기서, 플레이어별로 PlayerMove(Player, 0)이 생성됨
        - -> 리스트로 담겨서 Game이 갖고 있게됨
        - GameStatus는 뭐 PLAYING 이렇게 초기화하고
    - [x] game.move(MoveFactory)
        - List<PlayerMove>를 데리고 move를 해야지 : PlayerMove.move(MoveFactory)
- PlayerMove
- [x] PlayerMove에는 Player와 Distance
    - [x] PlayerMove.move(MoveFactory)
        - Distance++;
- 컨트롤러에서는: List<PlayerMove> 를 갖고가서 출력하면 될듯?
    - 아니면 responseDto로 만들어 갖고가서 출력하든지

## 예외 처리

- (예외 상황 시 "[ERROR]"로 시작하는 에러 문구를 출력한다.)
- 플레이어 이름을 입력 받을 때 예외 상황
    - [x] 공백인 경우
    - [x] ,로 구분되지 않은 경우 (한 명인 경우도 안됨)
    - [x] 다섯자 초과인 경우
- 시도할 횟수를 입력 받을 때 예외 상황
    - [x] 공백인 경우
    - [x] 숫자가 아닌 경우
    - [x] 0안 경우

## 입출력 기능

### 입력 기능

- [ ] 플레이어 이름을 입력받는 기능
- [ ] 시도할 횟수를 입력받는 기능

### 출력 기능

- [ ] 실행결과 문구를 출력
- [ ] 플레이어별 이동결과를 한 이동당 한번씩 출력
- [ ] 최종 우승자를 출력

(추후 삭제)

## 보완할 점

- [ ] MoveFactory가 역할이 4이상 숫자 판단에 의해 boolean 값 반환밖에 없다.
    - [ ] 거기다 메소드 하나만 있어서 생성자에 말고 메소드에 바로 numbergenerator를 주입해도 되지 않을까하는 생각.
-[ ] distance에 대한 validate 체크

## 프로그래밍 요구 사항

- indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다.
- 3항 연산자를 쓰지 않는다.
- 함수(또는 메서드)가 한 가지 일만 하도록 최대한 작게 만들어라.
- JUnit 5와 AssertJ를 이용하여 본인이 정리한 기능 목록이 정상 동작함을 테스트 코드로 확인한다.
    - 테스트 도구 사용법이 익숙하지 않다면 `test/java/study`를 참고하여 학습한 후 테스트를 구현한다.

## 자체 요구 사항

- 함수(또는 메서드)의 길이가 10라인을 넘어가지 않도록 구현한다.
- 배열 대신 컬렉션을 사용한다.
- 모든 원시 값과 문자열을 포장한다
- 일급 컬렉션을 쓴다.
- 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.

## TDD 원칙 ⭐️⭐️

- 원칙 1 - 실패하는 단위 테스트를 작성할 때까지 프로덕션 코드(production code)를 작성하지 않는다.
- 원칙 2 - 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
- 원칙 3 - 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

## TDD 사이클 ⭐️⭐️

1. 실패하는 테스트를 구현한다.
2. 테스트가 성공하도록 프로덕션 코드를 구현한다.
3. 프로덕션 코드와 테스트 코드를 리팩토링한다.

