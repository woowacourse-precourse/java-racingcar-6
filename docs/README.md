# 기능 목록

## UML
![java_racing_car.png](..%2F..%2F..%2FDocuments%2Fjava_racing_car.png)

## 기능 목록 리스트
1. Car는 난수 값에 따라 전진한다.
2. Race는 모든 자동차들의 위치를 알려준다.
3. Race는 가장 빠른 차를 알려준다.
4. Race에는 자동차를 추가할 수 있다.
5. Race는 모든 차를 한번에 움직일 수 있다.
6. Broadcaster는 실행 결과를 입출력 형태에 맞춰 사용자에게 보여준다.
7. Broadcaster는 최종 우승자를 입출력 형태에 맞춰 사용자에게 보여준다.
8. GameSystem은 사용자의 입력값을 검증한다.
9. GameSystem은 사용자의 입력값을 이용하여 게임을 진행한다.

## 사고의 흐름
1. 기능 목록을 만들기 위해선 기능 목록 당 구현할 책임들이 있어야 한다.
2. 책임을 어떻게 나눌 것인가?
3. 가장 간단한 형태의 책임 분할부터 시작해본다.
4. 모든 것을 하나의 객체가 처리한다.
5. 그러나 그것은 썩 좋지 못하다. 왜냐하면 어렵기 때문.
6. 그래서 가장 친숙한 클라이언트-서버 구조를 기반으로 사고를 이어가 보자.
7. 클라이언트는 보여지는 것을 담당한다.
8. 보여줘야 하는 결과는 실행 결과와 최종 우승자이다.
9. 그래서 서버는 실행 결과와 최종 우승자를 계산하도록 하자.
10. 여기서 한 가지 고민해볼 사항으로 서버와 클라이언트 간에 주고 받을 메세지를 따로 정의해야 할까?
11. 이는 이후에 고민하자. 왜냐하면 의존성 여부에 따라 달라질 수 있기 때문이다.
---
12. 자 그럼 이제 고민은 서버의 책임을 또 다시 어떻게 쪼개고 구현할 지이다.
13. 여기서 핵심적인 사항은 테스트 짜기 용이하도록 책임을 구현해야 하는 것이다.
14. 테스트 코드를 짜기 쉬운 코드란 내 생각에는 추상화가 잘 된 코드라 생각한다.
15. 퍼블릭하게 노출된 메서드로만으로 모든 것을 테스트 코드 내에서 재현할 수 있어야 한다.
16. 그렇기 때문에 서버의 책임을 분할 시킬 때 추상화가 잘 되도록 책임을 분할하자.
---
17. 실행 결과는 어떻게 구현해야 할까?
18. 먼저 자동차 객체를 만들고, 이를 리스트로 묶은 다음에 자바 컬렉션 API를 활용해서 전체 자동차가 움직이도록 하자.
19. 여기서 생각해볼 점은 각각의 자동차가 움직일 때마다 실행 결과를 출력할 지와, 모두 모아서 한번에 출력할 지이다.
20. 만약 각각 자동차가 움직일 때마다 출력한다면, 클라이언트는 실행 결과를 계산하는 서버쪽의 객체를 매번 직접적으로 참조해야 한다.
21. 만약 한번에 계산하여 한번에 모아서 출력한다면 단 한번만 참조하면 된다.
22. 즉, 여러 번 참조하는 형태냐 혹은 한번만 참조하는 형태냐의 여부이다.
23. 여기서 더 나아가 테스트 코드는 무엇이 더 좋을 지 생각해보자. 
24. 지금 당장 생각으로는 뭐가 더 좋은 형태인지 잘 모르겠다.
25. 분명한 것은 한번만 참조할 경우 반드시 클라이언트와 서버 간의 메세지를 주고 받는 스펙이 미리 정의되어야 한다는 것이다.
26. 이처럼 메세지가 추가되는 경우에 의존성이 더 강해진다고 생각하므로, 실행 결과는 매번 계산해서 클라이언트에 보여주는 쪽으로 구현해본다.
27. 그런데 만약 이런 형태가 불편하거나 안 좋은 점이 발견되는 경우에, 메세지를 통해 실행 결과들을 모아서 한번에 출력하는 형태로 구현해보자.
28. 지금 당장 생각해보니 매번 실행 결과를 출력한다고 해도, 메세지 객체가 필요할 수도 있을 것 같다.
29. 실행 결과를 얻기 위해선 차를 추가할 수 있어야 하고, 동시에 등록된 모든 차를 움직일 수 있어야 한다.
---
29. 최종 우승자는 어떻게 구현해야 할까?
30. 최종 우승자를 알기 위해선 모든 자동차의 위치를 한번씩은 완전 탐색해야 한다.
31. 그런데 모든 시도가 마무리 된 이후에 최종 시점의 위치를 받아와야 한다.
32. 그렇다면 위에서 실행 결과를 얻을 때도 재사용할 수 있도록 자동차의 위치를 반환하는 메소드를 구현하도록 하자.
33. 그렇다면 단순하게 자동차의 리스트만으로는 이를 구현할 수 없다.
34. 따라서 자동차의 리스트를 바탕으로 원하는 결과를 계산할 수 있는 책임, 즉 객체가 필요해진다.
35. 자동차 경주라는 컨텍스트에 맞게 심판(레퍼리?)이란 의미의 객체를 만들어서 사용하도록 하자.
---
36. 마지막으로는 전체 시스템을 총괄하는 객체를 만들자.
37. 이 객체는 사용자의 입력값을 검증하고, 해당 입력값을 객체의 파라미터로 전달한다.
---
38. 그리고 무엇보다 나는 요구사항이 변경될 때 롤백하는 것을 피하고자 한다.
39. 과제를 해보니 나는 단번에 완벽한 요구사항을 만들 수 없음을 깨달았다.
40. 중간 중간에 요구사항은 더 구체적으로 변하고 더 좋은 형태로 진화한다.
41. 따라서 이를 염두하여 각각의 객체는 독립된 브랜치에서 개발하고 마지막에 머지하도록 한다.
42. 심지어 요구사항마저도 독립된 브랜치로 만들어서 관리한다.
43. 따라서 필요한 경우가 아니라면 모듈 간의 의존성을 높이지 않아야 한다.
44. 모듈 간의 의존성이 낮은 설계를 하기 위해선 유사한 책임은 모아서 하나의 객체로 구현하면 된다.