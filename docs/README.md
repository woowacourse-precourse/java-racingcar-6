# 2주차 과제 개발 설계
## 📌목표

- MCV 패턴 원칙 정하기
- 테스트 코드 작성법을 제대로 익히고 사용하자
- 모듈은 하나의 기능 단위가 아닌 **하나의 행동**으로 간결히 만들자
- **javadocs 작성**하여 코드 가독성을 높이자

---

## 🖥️기능 목록

- **게임시작**
    - 레이싱 게임의 전체적인 흐름을 컨트롤하는 역할.
- **한판의 레이싱 게임 실행**
    - 레이싱게임이 실행되는 흐름을 컨트롤하는 기능으로 한판의 경주에 참여한 모든 자동차들의 게임 결과를 계산한다.
- **입력값 유무검사**
    - 공백이 있는지 .
    - 잘못된 값을 입력할 경우 `IllegalArgumentException`을 발생시킨 후 애플리케이션은 종료.
- **자동차 이름 유효성 검사**
    - 공백일 경우 예외 발생.
    - 5자 이하일 경우 예외 발생.
    - 잘못된 값을 입력할 경우 `IllegalArgumentException`을 발생시킨 후 애플리케이션은 종료.
- **경주 할 자동차 목록 만들기**
    - split(”,”) 를 통해 이름을 하나씩 분리한다.
    - 경주할 자동차들 하나의 목록 List<자동차>에 담는다.
- **시도 횟수 유효성 검사**
    - 숫자 외의 문자가 있을 경우 예외 발생.
    - int정수 최대 범위를 초과할 경우 예외 발생.
    - 0 을 입력할 경우 예외 발생.
    - 잘못된 값을 입력할 경우 `IllegalArgumentException`을 발생시킨 후 애플리케이션은 종료.
- **자동차 경주 한판의 전진 결과**
    - 각 자동차들은 임의의 값을 기준으로 전진하거나 멈춘다.
    - **전진 가능한 Random 수 얻기** 를 통해 각 자동차들의 Random 수를 얻는다
    - **********전진 랜덤 수 판단하기********** 를 통해 각 자동차들이 전진하거나 멈춘다.
- **전진 가능한 Random 수 얻기**
    - 경주에 참여하는 자동차들은 각각 Random 수가 필요하다.
    - 0에서 9 사이에서 무작위 값.
- **랜덤 수 전진 판단하기**
    - 무작위 값이 4 이상일 경우 한칸 전진.
- **자동차 실행 결과 가공하기**
    - 사용자에게 표현하기 위해 `자동차명 : 전진횟수` 형태로 데이터를 가공한다.
- **자동차 경주 우승자 결과 얻기**
    - **우승자 판단**과 **우승자 결과 데이터 가공**을 통해 자동차 경주의 우승자 결과를 얻는다.
- **가장 많이 움직인 전진 수 얻기**
    - 경주한 자동차 중 가장 많이 움직인 전진 수를 얻는다.
- **우승자 결과 데이터 가공하기**
    - 우승자가 여러 명일 경우 쉼표(,) 를 이용하여 구분한다.
    - 사용자에게 실행 결과를 화면에 보여준다.
- **메세지 출력**
- **게임 메세지 출력**

</br>

- **게임 메세지**
    - 게임 메세지 문구 정의
    - `경주할 자동차 이름을 입력하세요.(이름은 쉼표(,) 기준으로 구분)`
    - `시도할 회수는 몇회인가요?`
    - `실행 결과`
    - `최종 우승자 : {우승 자동차}`

---

## 👾아키텍처 설계
## **Model**

- Model은 View의 존재를 모른다.
- 오직 데이터의 가공과 모델의 비즈니스 로직 처리에만 책임이 있다.
- 비즈니스 로직을 처리하는 곳은 세부사항이다. 세부사항은 변경이 잦은 곳이기 때문에 다른 계층에 영향력을 전파하기 쉽다.

```java
class Car
	자동차 이름
	자동차 전진횟수
	
	전진 가능한 Random 수 얻기()
	랜덤 수 전진 판단하기()
```

```java
class Game
	시도 횟수

	가장 많이 움직인 전진 수()
	우승자 결과 데이터 가공하기()
```

</br>

## Service

서비스 계층을 도입한 이유는 Model 계층을 간결하게 유지하고, 변경이 잦기 때문에 다른 계층의 전파를 낮추기 위함이다.

- **도메인 모델 분리**: 각 도메인 모델은 자신의 역할에 집중히여 비즈니스 로직을 처리할 수 있다.
- **다양한 모델 간의 중재:** 모델들 간의 상호 작용을 처리(데이터 매핑)하여 결합도를 낮춘다.
- **유지 보수성 향상**: 비즈니스 로직을 중앙집중화 하기 때문에 비즈니스 규칙이 변경되거나 업데이트 되어야 하는 경우 Service 계층에서만 로직을 수정하면 된다.

```java
class CarGameService

	경주 할 자동차 목록 만들기()

	한판의 레이싱 게임 실행(){
		사용자 시도 횟수 실행 때 마다 줄이기
		자동차 경주 한판의 전진 결과()
	}

	자동차 경주 한판의 전진 결과(){
		전진 가능한 Random 수 얻기()
		랜덤 수 전진 판단하기()
	}
	
	자동차 실행 결과 가공하기()

	자동차 경주 우승자 결과(){
		우승자 판단하기()
		우승자 결과 데이터 가공하기()
	} 
	
```

</br>

## View

- View는 Model의 존재를 모른다.
- 사용자 입력에 대한 최소한의 유효성 검증을 처리한 후 Controller에 전달
- 모델의 데이터를 사용자에게 표시하는 역할

```java
class InputView
	입력값 유무검사()
```

```java
class OutputView
	메세지 출력()
	게임 메세지 출력()
```

</br>

## Controller

- Model과 View의 존재를 안다
- 컨트롤러는 Model과 View에게 액션을 취하도록 하는 역할로 가장 직관적이고, 간단해야 한다.
- 사용자 입력에 대한 유효성 검증과 예외처리를 한다.

```java
class CarController
	게임 시작() {
	  경주할 자동차 이름을 입력

	  경주할 자동차 목록

	  시도할 회수 입력
	
	  실행 결과

	  자동차 게임 실행
	
	  최종 우승자 선정
	
	}

	자동차 이름 유효성 검사()
	시도 횟수 유효성 검사()
```
