## 기능 명세

### 구현 플로우

1. 사용자로부터 경주 할 자동차 이름을 받아온다.
    1. 이름의 개수로부터 생성할 객체의 수를 파악할 수 있다.
2. 사용자로부터 시도할 횟수를 받아온다.
3. 해당 정보를 바탕으로 자동차 객체를 만든다.
4. 매 플레이마다 객체에서 랜덤값을 받아오고, 해당 내용으로 전진 카운트를 계산한다.
5. 해당 카운트를 바탕으로 사용자에게 카운트 값을 슬래시로 출력한다.
6. 4~5를 반복하며 최종 우승자를 출력한다.

### View

- **Input**
    - 경주할 자동차를 받아온다
        - • 사용자가 입력하는 값은 `camp.nextstep.edu.missionutils.Console`의 `readLine()`을 활용한다.
        - 쉼표를 기준으로 경주가 진행되기에, 쉼표에 따라 문자열을 나누어 객체를 생성해야 한다.
        - 자동차의 이름은 문자만 가능하며, 5자 이하여야 한다
            - `Exception` 숫자, 공백, 5자 이상의 경우 잘못된 값으로 간주된다.
            - `Exception` 이름은 중복이 허용되지 않는다. **(추후 변경 가능)**
    - 경주 시도 횟수를 받아온다.
        - 경주 회수는 자연수만 가능하다 (음수나 유리수는 잘못된 값이다.)
        - `Exception` 문자나 공백이 입력되지 않도록 한다.
- **Output**
    - 매 게임 회차가 진행했을 때, 만들어진 객체별로 카운트를 출력해야 한다.
    - 회차가 끝났을 때 최종 우승자를 출력해야 한다.
        - 만약 우승자가 2명 이상이라면 쉼표를 통해 함께 출력한다.

### Model

- 자동차 객체 → 다형성 적용
    - 랜덤으로 무작위 값을 계산해야 한다. 계산된 결과에 따라 Go, Stop으로 구분하여 리턴한다.
        - • Random 값 추출은 `camp.nextstep.edu.missionutils.Randoms`의 `pickNumberInRange()`를 활용한다.
        - ex) 0에서 9까지의 정수 중 한 개의 정수 반환

          `Randoms.pickNumberInRange(0,9);`

- 실행 결과를 관리하는 객체
    - 각 객체별로 Count를 확인할 수 있어야 한다.

### Controller

### Util

---

## 지켜야 할 요구사항
### 공통
- indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다.
    - 예를 들어 while문 안에 if문이 있으면 들여쓰기는 2이다.
    - 힌트: indent(인덴트, 들여쓰기) depth를 줄이는 좋은 방법은 함수(또는 메서드)를 분리하면 된다.
- 3항 연산자를 쓰지 않는다.
- 함수(또는 메서드)가 한 가지 일만 하도록 최대한 작게 만들어라.
- JUnit 5와 AssertJ를 이용하여 본인이 정리한 기능 목록이 정상 동작함을 테스트 코드로 확인한다.
    - 테스트 도구 사용법이 익숙하지 않다면 `test/java/study`를 참고하여 학습한 후 테스트를 구현한다.

### 개인적으로 이건 꼭 완성해보자!
- MVC 모델을 적용해보자.
- 출력문과 예외문은 상수처리하자.
