# 요구사항 분석

> ## 입력
>### 자동차 이름을 쉼표로 구분하여 입력받는다. 
>  - [x] 자동차 이름은 5자 이하만 가능하다.
>  - [x] 자동차 이름은 공백이 포함되지 않는다.
>  - [x] 자동차 이름이 중복될 경우 인덱싱을 통해 구분한다.
>  - [x] 자동차 이름은 쉼표로 구분한다.
>### 시도할 회수를 입력받는다.
>  - [x] 시도할 회수는 숫자만 가능하다.
>  - [x] 시도할 회수는 1 이상 999 이하 이다.

>## 출력
>### 각 차수별 실행 결과를 출력한다.
>  - [x] 각 차수별 실행 결과는 자동차 이름과 함께 출력한다.
>  - [x] 각 차수별 실행 결과는 '-'로 표시한다.
>### 단독 우승자를 출력한다.
>  - [x] 단독 우승자는 한 명이다.
>  - [x] 단독 우승자는 실행 결과가 가장 많은 유일한 자동차이다.
>### 공동 우승자를 출력한다.
>  - [x] 공동 우승자는 두 명 이상이다.
>  - [x] 공동 우승자는 실행 결과가 가장 많고 같은 자동차이다.

---

# 추가 게임 설정과 규칙
>### 사용자 입력
>1. 자동차 이름은 1~5자 사이로 입력할 수 있으며 빈칸이 되어서는 안됩니다.
>2. 자동차 이름들은 쉼표로 구분하며 쉼표로 구분되지 않은 경우 하나의 자동차로 간주합니다.
>3. 자동차 이름들은 중복될 수 있으며 중복된 경우 인덱싱을 통해 구분합니다.
>4. 자동차 이름에는 언더바("_")가 포함될 수 없습니다.
>5. 시도할 회수는 1~999 사이의 숫자만 입력할 수 있습니다.
>6. 잘못된 입력이 들어올 경우 게임은 그 즉시 중단됩니다.

>### 게임 진행
>1. 자동차들은 라운드마다 각각 0~9 사이의 랜덤 값을 뽑으며 이 값이 4 이상일 경우 전진합니다.
>2. 자동차 수가 1개라도 게임은 진행되며 해당 자동차가 반드시 우승합니다.
>3. 자동차 수가 2개 이상일 경우 가장 많이 전진한 자동차가 우승합니다.
>4. 자동차 수가 2개 이상일 경우 가장 많이 전진한 자동차들이 공동 우승합니다.
>5. 우승자가 여러 명일 경우 쉼표로 구분하여 출력합니다.
>6. 게임이 진행하는 동안 아무도 전진하지 않아 모두 0의 위치를 유지하면 모두가 우승자가 됩니다.

---

# 고려한 예외 상황
>1. 자동차 이름이 5자 이상인 경우
>2. 자동차 이름이 빈 칸인 경우
>4. 자동차 이름에 언더바가 포함되는 경우
>5. 시도 횟수가 1 미만인 경우
>6. 시도 횟수가 999 초과인 경우
>7. 시도 횟수가 숫자가 아닌 경우

---

# 고민해 본 내용
## 자동차 이름 입력 검증 기능
>### 1. 정규표현식과 다중 조건문
>- 정규표현식을 사용해서 자동자 정보 문자열을 검증하면 간단한 코드 한줄로 검사가 가능해집니다. 하지만 다양한 조건을 한 표현식으로 검사하다 보니 공백이 들어가던, 5자 이상이 들어가던 여러 예외 상황에 대해 똑같은 에러를 발생시킵니다. 
>- 이에 비해 다중 조건문은 각 조건에 맞는 에러를 발생시킬 수 있습니다. 하지만 코드가 길어지고, 조건이 많아질수록 코드가 복잡해집니다.
>- 저는 이 두 가지 방법 중 정규표현식을 선택했습니다. 정규표현식을 사용하면 코드가 간결해지고, 검증 조건이 추가되더라도 정규표현식 하나만 수정함으로써 해결이 가능해 코드의 유지보수가 용이하기 때문입니다.
>- 또한, 다양한 조건에 대한 공평한 예외처리를 위해 에러 메시지로 정확한 규칙을 한 번에 전달하기 위해 노력했습니다.
>- ㄴ> 위와 같은 내용으로 구현하고 보니 <u>정규표현식을 사용하기 위한 Patterns 객체의 비용이 비싸다는 사실을 알게 되었습니다. 검증하고자 하는 문자열의 길이가 길어질수록 비용이 급격하게 증가할 것으로 판단되어 간단한 조건문으로 재구현하고 예외상황에 맞춰 에러 메시지를 출력했습니다.</u>

>### 2. 중복 이름에 대한 처리 방식
>- 같은 이름이 들어온 경우는 두 가지 방법으로 처리할 수 있습니다.
>  1. 같은 이름이 들어온 경우 예외를 던집니다.
>  2. 같은 이름이 들어온 경우 인덱싱을 통해 구분합니다.
> 
> - <u>저는 같은 이름이 들어와도 예외를 던지지 않고 같은 이름들 사이에 인덱싱을 통해 구분했습니다.</u> 구현 과정에서 코드의 복잡도가 살짝 올라가지만 같은 이름일 경우에도 게임이 진행된다면 더욱 유연한 사용자 경험을 줄 수 있을 것이라 생각했습니다.
> - 또한, 같은 이름이 들어온 경우 예외를 던지면 사용자가 다시 입력을 받아야 하기 때문에 사용자 경험에 좋지 않다고 생각했습니다.
> - 이름 별로 <u>해시맵에 키를 추가하고 갯수를 벨류로 설정했습니다. 만약 해시맵에 키가 존재한다면 키의 벨류를 1 증가시키고 해당 순서의 차 이름에 인덱스를 추가했습니다</u>
> - 이렇게 함으로써 같은 이름이 들어온 경우에도 예외를 던지지 않고, 같은 이름들 사이에 인덱싱을 통해 구분할 수 있었습니다.

> ### 3. 중복 인덱싱의 직접 입력 처리
> - 먼저 2번에서 구현한 중복 기능은 인덱싱을 통해서 같은 이름의 자동차를 구분합니다. 만약 "A,A" 라는 입력이 들어올 경우 A,A2 라는 자동차가 생성됩니다. 하지만 여기서 만약 "A,A,A2"라는 입력이 들어온다면 어떻게 되어야 할까요?
> - <u>저는 이에 대한 대답으로 특수문자를 적용했습니다. 기존에는 자동차에 특수문자가 들어가면 안된다는 조건이 존재하지 않아 어떤 특수문자던 간에 상관없었지만 언더바만을 제외함으로써 중복이름에 대한 예외상황을 회피할 수 있었습니다.</u>
> - 언더바만을 제외하기 위한 방법을 오래 고민해보았지만 모든 문자를 탐색하는 것이 아니라면 불가능하다고 판단되었고 정규표현식과 contains() 메서드 중 contains() 메서드를 사용하기로 결정했습니다.

## 추상화
>### Validator 추상화
> - 자동차 리스트 입력과 시도 횟수 입력에 대한 유효성 검사를 진행하다 보니 두 클래스가 비슷한 메서드를 가지고 있는 것을 발견했습니다.
> - 후에 서비스가 더 발전하여 다양한 입력 기능이 생기고 더욱 많은 유효성 검사 클래스가 생긴다면 중복되는 코드가 많아질 것이라고 판단했습니다.
> - 이에 저는 유효성 검사 클래스에서 필수로 구현해야 하는 메서드들을 추려 인터페이스로 추상화했습니다.

## 

