# 1주차 공통 피드백 - 자가 피드백

---

1. 브랜치 관리를 전혀 하지 않고 1주차 과제를 제출했었는데, 이번에는 기능 구현을 위해 새로 만든 브랜치에서 작업 후 PR을 보내야겠다.
2. 한 번의 모든 코드를 작성하고 단 한번의 커밋으로 PR을 보냈었는데, 이번에는 구현 중간중간에 커밋을 통해 기록을 남기고 관리해야겠다.
3. 전 과제에서 자바 자료구조를 사용하지 않고 배열로 간단하게 구현했었는데, 그렇게 하지 말고 자바에서 제공하는 자료구조와 이를 효과적으로 사용하기 위하여 제공하는 API 또한 공부하고 사용해야겠다.
4. 그리고 전에는 모듈화를 한 자바 클래스 파일 안에서만 진행했었는데, 기능 별로 모듈화를 강화하는 방향으로 코드를 작성해야겠다.

---


# 구현 - 자동차 경주

---

보자마자 간단하게 flow 생각하기
1. 자동차 입력 받기
2. 시도할 회수 입력 받기
3. 게임 시작
4. 턴마다 각 자동차의 전진여부 결정
5. 전진 처리 후 4번으로 복귀
6. 게임 종료
7. 우승자 결정

---

적용할 디자인 패턴 - MVC 패턴 + 싱글톤 패턴
- 유저에게 게임을 배포한다는 느낌으로
- 간단하게 시작하기 전에 그려본 구조도

![img](https://cdn.discordapp.com/attachments/1156230299202625608/1167752576792535120/2023-10-28_6.11.46.png?ex=654f4556&is=653cd056&hm=e57c9a13cbcbbd70ee0931cff06834920427c4462b4fc10432b8cd2d827d54b6&)

---

### 1. getCarsName - 자동차 입력 받기

- 자동차 이름을 유저로 부터 입력 받음
- 콤마를 기준으로 파싱
- 입력 유효성 조건은 하나만 주어짐. 이름은 다섯자 이하만 가능
- 같은 이름, 이름이 null string인 경우도 안됨

### 2. getPlayTime - 시도할 회수 입력 받기

- 게임을 몇회나 진행할 것인지 입력을 받음
- 0 이하의 숫자가 들어오면 오류라고 판단

### 3. setRandomNum - 전진 여부 판단을 위한 기준 뽑기

- 랜덤 숫자를 하나 뽑음
- Randoms에 들어있는 pickNumberInRange 메소드를 이용
- chkCarsGoOrStop 함수를 호출하여 자동차를 움직일지 말지 결정

### 4. chkCarGoOrStop - 전진 여부를 결정

- 자동차를 움직일지 말지 결정
- setRandomNum 에서 뽑은 숫자를 이용해서 4이상일 경우에 true를 반환

### 5. setCarMove - 전진 내용을 갱신

- 자동차가 움직이게 된다면 움직임을 갱신
- chkCarGoOrStop에서 반환한 값을 이용해서 true일 때 움직임을 갱신

### 6. printCarsMove - 전진 결과를 출력

- 자동차의 지금까지 움직임을 출력

### 6. chkWinners - 승자를 결정

- 게임 과정을 통해서 결정된 승자를 찾고 반환
- 승자는 여러명일 수 있음

### 7. printWinners - 승자를 출력

- chkWinners에서 반환한 값을 통해 승자를 출력

---

기능구현 이후 리뷰

- cleanup 함수의 구현
이는 테스트 함수를 열심히 굴려보다가 구현하게 되었는데, 전에 들어갔던 데이터가 제대로 정리되지 않아서 종종 문제가 발생하는 경우가 있었다.
이를 위해서 cleanup 함수를 통해서 전체 프로세스가 종료되면 지금까지 있던 데이터들을 회수하는 과정을 거치게 하였다.

- 메소드와 함수 이름의 Abstraction
메소드와 함수들을 각자의 기능별로 잘게 나누고, 이름을 보고 어떤일을 하는 지 충분하게 알게 만들었다. 이를 통해서 거의 주석을 달지 않았다.
주석이 없어도 메소드와 변수 이름으로 하고자 하는 일을 충분히 나타낼 수 있는 코드가 되었다고 스스로 판단했기 때문이다.

- 멤버 변수의 선언
멤버 변수는 해당 model에 종속되어야 하는 정보, 해당 모델과 관련있는 정보만 저장할 수 있게 설계했다. 이것이 서로의 의존성을 많이 낮춰준다 판단했다.

- List<Map.Entry<String, String>> 의 사용
이번 과제 명세를 수행하기 위해서 몇 가지 고민한 사항이 있었다. 결과 출력을 보면 항상 처음에 입력이 들어온 순서대로 결과를 출력해야 한다고 생각했다.
그래서 이를 위해 key - value를 이용한 HashMap을 이용해서 저장을 하려 했는데, 이는 순서가 항상 보장된다고 하지 않아서 linkedHashMap을 사용했었다.
그런데 생각해보면 이는 마치 c++에서 사용하는 pair 컨테이너를 이용해서 저장을 해 index로 접근하게 된다면 편리해질 것 같았다.
항상 결과 출력이 입력이 들어온 순서대로 결과를 출력해야 한다는 것은 마치 각 자동차에 인덱스가 붙은 것과 같다고 판단했다. 그래서 혹시 자바에서도
그런 pair와 같은 기능을 사용할 수 있는 방법이 없을까 찾아보았는데 List<Map.Entry<String, String>> 이런식으로 사용할 수 있다는 것을 발견했고
이를 이용해서 과제를 마무리했다. 자동차 이름을 어차피 UserInput에 저장을 순서대로 해두었기 때문에 이를 key로 HashMap을 참조하는 것도 하나의 방법이었다 라고
생각하기도 하는데, index로 접근할 수 있고 이를 list로 관리할 수 있다는 것은 결과를 출력할 때 sort하기에 편리하는 것과 같아서 이러한 구조로 진행했다.

- 전진 결과 저장
string으로 내가 한 것 처럼 저장할 수도 있고 얼만큼 갔는지 길이를 int로 저장하는 것도 방법이 있었는데, 숫자로 적으면 이를 출력할 때마다 for문을 돌아야해서
이는 게임이 많아지면 많아질수록 시스템에 좋지 않은 영향을 줄 것이라고 판단해서 그렇게하지 않았다. 그래서 그냥 string으로 저장하고 car의 대수만큼
string을 찍는 방식으로 구현했다.

- 입력 유효성 검사 중 공백 문자에 대한 고민
이것을 어떻게 처리할까 하다가 생각한 예시가 이것이었다. "pobi, java" 이런식으로 입력이 들어온다면 뒤에 있는 java를 공백문자를 포함해서 다섯글자로 볼 것인가?
이것은 디자인 철학에 문제라고 생각해서 과연 내가 생각하는 여기서 어울리는 디자인은 무엇일까 고민해보았다. 이름을 길게 입력할 수 없고 다섯글자만 받을 수 있다는 점,
유저가 입력 과정에서 white space를 넣는 실수를 할 수 있다는 점에서 공백문자는 이름에 포함될 수 없다고 판단했고, 그렇다고 공백문자를 입력에 못넣게 하는 것은
유저가 그렇게 좋아할 경험이라고 생각하지는 않아서 내가 알아서 공백문자를 제외하고 입력을 받게 구성했다. 그렇다면 유저가 공백문자를 이름에 넣고 싶은데 못 넣는 것도
좋아하지 않는 경험이라고 생각할수도 있으나, 이를 고민하기에는 이름의 길이가 충분히 짧다고 생각했다. 

이번 과제에서 중점적으로 고려한 구현 포인트가 몇 있었다.

- OOP
- Abstraction
- Information hiding
- Encapsulation
- MVC pattern
- singleton pattern

이번 2주차 과제에서 핵심으로 다루는 부분 "함수의 분리"였다. 그래서 이를 이번 과제에 어떻게 적용하면 좋을까, 
고민하다가 전에 nestJS로 프로젝트를 했던 기억이 났고, 이를 조금 응용해보기로 했다.

함수를 분리하고 객체 단위로 나누어서 코드를 관리하기 위해서는 로직을 어떻게 작성할까보다는 아키텍쳐를 어떻게 구성할 것인지가 중요했다.
그래서 MVC 패턴을 적용하기로 했다. 그리고 후에 구현 과정에서 리펙토링을 하다가 아키텍쳐 패턴과 디자인 패턴이 차이가 있고,
이를 프로젝트를 만들기 전에 필요에 따라 정하는 것이 중요하다는 것을 학습했다. 
그래서 나의 과제는 결과적으로 MVC 아키텍쳐 패턴과 singleton 디자인 패턴을 가진 작은 프로젝트가 되었다.

MVC 패턴을 고른 이유는 우선 우아한테크코스에 합격을 하게된다면 자바 스프링 프레임워크를 공부하는 것으로 알고 있는데,
자바 스프링에서 MVC 패턴을 이용하는 것으로 알고 있었기 때문에 미리 구조를 느껴보는 것이 중요하다고 생각했다.
그리고 여러가지 아키텍쳐 패턴을 공부해보는 과정에서 MVC가 동시다발적 개발가능성과 서로의 의존성을 줄이고 각자 할 일만 하게 해서 효율성이 좋으며,
유지보수, 확장성, 유연성 측면에서 유리해 많은 프레임워크에서 이 아키텍쳐 패턴을 사용하고 있다는 것을 확인해서 MVC패턴을 사용하지 않을 이유가 없었다.

Singleton 패턴을 고른 이유는 한 번의 게임 안에서는 단 하나의 데이터가 있어야 한다는 것이 자명하다고 생각했기 때문이다.
각 model들에 종속된 변수와 컨테이너들은 한 게임 안에서 굳이 여러번 만들어질 필요가 없기에 더 만들어질 가능성이 존재한다면 이는 메모리 누수로 이어지고
오류가 발생할 수 있는 확률이 증가한다고 생각했다. 이를 구현하기 위해서 자바 싱글톤 패턴을 구현하는 방법을 찾아 공부하고 적용했다.

처음에 이런 패턴으로 만들어야겠다, 라고 생각하고 시작하긴 했으나 구현 과정에서 바로 이를 적용하기는 어려웠고 리펙토링하는 과정에서 이에 가깝게 변경하는
과정을 거쳤다. 하지만 덕분에 이 과정에서 아키텍쳐 패턴과 디자인 패턴은 어떤 것을 선택할까 보다 왜 이 패턴을 선택했는지에 대한 이유가 더 중요하다는 것을 배웠다.

이렇게 결정된 패턴 속에서 자바라는 언어가 가지는 객체지향의 특징을 살려보기 위하여 노력했다.
멤버 변수와 메소드들은 get,set 함수를 통해서만 접근이 되게 한다던지, private 키워드를 적절히 배치해서 외부참조로부터 확실하게 가능성을 제거한다던지.
원래는 잘 만들어져있는 프레임워크 위에서 그 길을 걸어가는 것만 해보다가 이렇게 직접 구조를 만들고 설계하는 것에서 몰입하며 즐거운 시간을 보냈다.

이러한 경험을 바탕으로 다음주 과제에도 더 몰입해보고 싶다. 이번주에 했던 많은 디자인에 대한 공부가 다음주에 더 멋진 과제 결과물을 안겨줄거라 믿는다.



