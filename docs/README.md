## 🎯 기능 구현 목록(단계별)
### 1. 자동차 값 입력, 검증, 저장

    1-1. 사용자로부터 자동차 이름 입력
    1-2. 자동차 이름 검증
    1-3. 자동차 객체 생성 및 저장

### 2. 자동차 이동 회수(차수) 값 입력, 검증, 저장

    1-1. 사용자로부터 자동차 이동 회수 입력
    2-2. 자동차 이동 회수 검증

### 3. 차수별 경주 실행 및 결과 출력

    (loop: 자동차 경주 이동 1회 단위)
    3-1. 자동차 단위 난수 생성, 이동 / 정지 판별 후 이동
    3-2. 차수별 이동 결과(자동차별 누적 이동거리) 출력

### 4. 우승자 출력

    4-1. 자동차별 누적거리 비교, 최고점수 리턴
    4-2. 누적거리 최대의 자동차 리스트(우승자) 출력

## 💻 구현 이력
    1. ('23. 10. 26.) 메인 구현
    2. (`23. 10. 26.) 기능 목록 1단계 구현
    3. (`23. 10. 27.) 기능 목록 2단계 구현
    4. (`23. 10. 27.) 기능 목록 3단계 구현
    5. (`23. 10. 27.) 기능 목록 4단계 구현
    6. (`23. 10. 28.) 기능 단위 리팩토링(코드 간결화)
    7. (`23. 10. 28.) 기능 단위 테스트 코드 작성

## 구현, 과정 목표
1. `기능 단위`로 구현하고, 커밋한다.
2. `기능 단위`로 테스트한다.
3. `커밋 컨벤션`을 준수한다.


## 🔥 향후 리팩토링 및 학습 목표
1. `코드 컨벤션`을 준수하여 리팩토링한다.
2. `DTO` 에 대해 명확히 이해하고 Getter 의 용도에 맞게 리팩토링한다.
3. `Junit`을 활용한 `TDD` 개발법에 대해 학습하고, 기능 단위로 실천한다.

## (부록) 코드 컨벤션, 공통 피드백 준수 여부
```달성 수준 : 미달성 ⬛ , 중간 🔼 , 달성 ✅ 로 구분```

[코드 컨벤션]

    ✅ 한 함수(메서드)에 최소한의 들여쓰기(indent)만 허용한다
    ✅ else 예약어를 쓰지 않는다            
    ✅ 모든 원시값과 문자열을 포장한다        
    ✅ 콜렉션에 대해 일급 콜렉션을 적용한다   
    ✅ 3개 이상의 인스턴스 변수를 가진 클래스를 구현하지 않는다      
    ✅ 핵심 로직을 구현 도메인 객체에 getter/setter를 쓰지 않고 구현한다(단, DTO는 허용한다)    
    🔼 코드 한 줄에 점(.)을 하나만 허용한다     
    ✅ 메소드의 인자 수를 가능한 줄이기 위해 노력한다    
    ✅ 디미터(Demeter)의 법칙을 준수한다
    ✅ 클래스를 작게 유지하기 위해 노력한다(메서드 당 라인 10까지)    
    ✅ 매직 리터럴 / 매직 넘버 사용을 자제하고 상수를 사용한다    
    
[공통 피드백]
    
    ✅ 추가 요구사항을 준수한다
        ✅ 인덴트 depth 3 이하로 구현한다
        ✅ 3항 연산자를 사용하지 않는다
        ✅ 함수가 한가지 일만 하도록 구현한다
        ✅ JUnit 5, AssertJ 이용하여 기능 단위 테스트 코드를 작성한다


    ✅ 커밋 메시지를 의미있게 작성한다
    ✅ git을 통해 관리할 자원에 대해서 고민한다
    ✅ PR을 보내기 전 브랜치를 확인한다
    ✅ PR을 닫기 전 추가 커밋을 한다
    ✅ 이름을 통해 의도를 드러낸다
 