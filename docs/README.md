### 기능 요구 사항

-[x] 경주 자동차 이름 입력 메시지 출력
-[x] 사용자로부터 이름 입력 받기
    -[x] 이름의 구분은 ,(쉼표)로 한다.
        - 쉼표 여부 : 쉼표가 있다면 경주차가 두 대 이상, 쉼표가 존재하지 않는다면 경주차가 한 대 존재
    -[x] 쉼표(,)를 통해 구분한 이름의 앞 or 뒤에 공백이 있다면, 이를 제거한 후 다른 조건들을 확인한다
    -[x] 이름의 길이는 5 이하만 허용   
     -> 5 초과시 예외 처리 후 어플리케이션 종료
    -[x] 자동차의 최대 개수를 INT_MAX로 가정  
     -> INT_MAX 값 초과 시 예외 처리 후 어플리케이션 종료
    -[x] 경주차끼리의 이름의 중복 여부 확인 후, 중복이 존재한다면 예외 처리 후 어플리케이션 종료

-[x] 경주 시도 횟수 묻는 메시지 출력
-[x] 사용자로부터 시도 횟수 입력받기
    -[x] Integer형으로 입력받는다고 생각하고, INT_MAX 값의 이상인 경우 예외 처리
-[x] 각 사용자에 대해 전진 여부 구하기 및 라운드 진행 및 출력
    -[x] 0에서 9까지의 랜덤한 숫자를 뽑은 후, 해당 값이 4 이상인 경우에 전진 가능
    -[x] Randoms.pickNumberInRange()를 통해 랜덤한 값을 구한다
    -[x] 진행 상황을 전달 받아서 출력
-[x] 시도 횟수만큼 진행했을 때, 전진한 칸의 개수에 따라서 최종 우승자를 출력한다.
    -[x] 이동한 칸이 같은 공동우승자가 발생할 수 있는데, 자동차 이름 입력 순서에 맞춰서 출력한다.

---

### 클래스 별 기능 요구 사항

---

### 실행 결과 예시

```
경주할 자동차 이름을 입력하세요.(이름은 쉼표(,) 기준으로 구분)
pobi,woni,jun
시도할 회수는 몇회인가요?
5

실행 결과
pobi : -
woni : 
jun : -

pobi : --
woni : -
jun : --

pobi : ---
woni : --
jun : ---

pobi : ----
woni : ---
jun : ----

pobi : -----
woni : ----
jun : -----

최종 우승자 : pobi, jun
```

---

#### 자동차 경주 로직 설계

[HashMap을 이용하는 방법✅]
경주 자동차들의 상태는 어떻게 저장 할 것인가? -> 게임이 한 번만 이루어지기 때문에 HashMap을 통해 저장해도 될 듯  
HashMap 사용하면 좋은 점: DTO를 따로 사용하지 않아도 된다. key에는 경주차 이름, value에는 전진한 칸 수  
HashMap를 전역변수로 저장해서 이를 이용하기

1. raceService에서 init() 메서드를 통해 HashMap 초기화 : 경주차 이름을 전부 전달받아서 HashMap에 저장
2. while(count++ < 시도횟수)를 통해 계속 돌게 만들고
3. raceService를 통해 각 라운드를 플레이하고, raceService 내의 HashMap을 계속해서 갱신
4. 갱신과 동시에 DTO를 생성해서 전달 -> OutputView에서는 DTO를 통해 출력
5. 전체 시도횟수가 끝나면 raceService의 HashMap을 통해 최종 우승자 결과를 전달받음
6. OutputView를 통해 최종 우승자를 출력

[List< Progress>를 이용하는 방법]

1. while(count++ < 시도횟수)를 통해 계속 돌게 만들고
2. raceService를 통해 각 라운드를 플레이하고, 매 라운드마다 결과를 List< Progress>로 반환
    - Progress: 경주차 한 대의 진행 상황. 경주차 이름 + 전진한 칸 수. 칸을 전진하는 메서드 필요
3. OutputView에서 결과를 받아서 그대로 출력
    - List< Progress>를 매번 순회하면서 출력
