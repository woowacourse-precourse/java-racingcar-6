### 설계 목표

---
1. [미션-자동차 경주](https://github.com/WinterHana/java-racingcar-6)에서 요구 조건에 맞춰 구현한다.
2. 클래스 내의 메서드를 최대한 분리한다. 즉, 기능을 최대한 분리하여 작업한다.
3. **객체 지향 원칙**에 맞춰서 프로그래밍한다.
4. 다른 프로그래머가 보기 편하게 최대한 클린코드 및 코드 컨벤션에 맞춘다.


### 기능 목록

---
1. **Car** : 경주 게임을 할 자동차 클래스
    1. 필드
        1. String name : 자동차의 이름
        2. int distance : 이동한 거리
    2. 생성자
        1. _(String name)_ : 이름을 받아서 새로운 Car 객체를 생성한다.
    3. 메서드
        1. moveRandom() : 무작위의 이동거리를 distance에 더한다.
        2. toString() : 출력할 내용을 설정한다.
        3. equals() : 객체 간 비교를 이동한 거리로 하기 위해서 Comparable를 상속받아 오버라이딩한다.
2. **RacingGame** : 경주 게임을 실행하는 클래스
    1. 필드
        1. ArrayList<Car> racingCars : 경주에 참가하는 Car를 저장하여 관리한다. ArrayList를 사용한 근거는 다음과 같다.
           >- 저장 후에 데이터를 변경할 일이 있는가? → No, 단, 데이터 정렬이 한 번 필요할 예정이다.
           >- 중복을 허용하는가? → No, 단 중복이 되면 예외 처리 후 프로그램이 종료된다.
           >- 저장 순서를 지키는가? → Yes
           >- [Key : value]의 형식을 허용하는가? → No
           >- 정렬이 필요한가? → Yes
           >- 탐색을 많이 할 것인가? → Yes
           >
           > 이러한 근거를 볼 때 데이터를 처음에 삽입 후 마지막에 데이터 정렬만 한 번 할 정적인 데이터를 관리할 때는 ArrayList가 적합하다고 판단된다.

    2. 생성자
        1. _(String cars)_ : 문자열을 입력받아서 Car 객체를 생성, racingCar에 저장한다.
    3. 메서드
        1. playGame(int step) : 시도할 횟수를 입력받아 게임을 실행한다.
        2. executeStep() : 각 Car 객체에 대하여 moveRandom()을 실행한다.
        3. printStep() : 하나의 실행에 대하여 결과를 출력한다.

3. **ApplicationTest** : 각종 예외에 대하여 테스트 코드를 추가한다.
    1. 정상_테스트 : 예외가 발생하지 않은 경우에 대하여 테스트한다.
       
    (추가 예정)

### 상수 관리

---
1. ErrorMessage : 각종 에러에 대하여 static String으로 관리한다.
2. NAME_LENGTH = 5 : 최대 이름 길이를 관리한다. 만약 초과한다면 예외 처리를 한다.
3. STEP_PERCENTAGE = 4 : 하나의 시도에 전진할 확률을 설정한다. 0~9까지 하나씩 오를수록 대략 10%씩 확률이 오른다.