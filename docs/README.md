- 입력을 관리하는 클래스
    - 자동차 이름은 쉼표(,)를 기준으로 구분하며 이름은 5자 이하만 가능하다.
    - 사용자는 몇 번의 이동을 할 것인지를 입력할 수 있어야 한다.
    - [x] 입력을 받는 메서드 작성
    - [x] 입력이 유효한지 확인하는 메서드 작성
      - [x] 같은 이름이 들어오는지 확인하는 메서
- 입력 유효성 검사 클래스
  - [x] 유효성 검사 메서드 테스트
  - 사용자가 잘못된 값을 입력할 경우 `IllegalArgumentException`을 발생시킨 후 애플리케이션은 종료되어야 한다.
- Car 클래스
    - 멤버 변수로 자동차의 이름과 이동 거리를 가지는 클래스
        - 각 자동차에 이름을 부여할 수 있다.
    - [x] 전진/정지 메서드
        - Random 값 추출은 `camp.nextstep.edu.missionutils.Randoms`의 `pickNumberInRange()`를 활용한다.
        - 전진하는 조건은 0에서 9 사이에서 무작위 값을 구한 후 무작위 값이 4 이상일 경우이다.
    - [x] `toString()` 메서드 재정의
        - 전진하는 자동차를 출력할 때 자동차 이름을 같이 출력한다.
    - [x] 유닛 테스트 코드 작성
- 우승자를 판단하는 클래스
    - 자동차 경주 게임을 완료한 후 누가 우승했는지를 알려준다. 우승자는 한 명 이상일 수 있다.
    - [x] 우승자 이름으로 이루어진 리스트를 반환하는 메서드
    - ~~`toString()` 메서드 재정의~~
        - 우승자가 여러 명일 경우 쉼표(,)를 이용하여 구분한다.
    - [x] 유닛 테스트 코드 작성
- 출력을 관리하는 클래스
  - StringBuilder를 이용해서 출력할 것을 갖고 있으면 좋을 것 같다.
  - [x] "실행 결과" ~~출력~~ StringBuilder에 추
  - [x] 한 번씩 움직였을 때 출력할 내용을 기록하는 메서드
  - [x] 우승자 내용을 기록하는 메서드
- Game 클래스
    - [x] 게임을 진행하는 클래스
      - 일단 어플리케이션 테스트는 통과!
    - [x] 메서드 분리
    - [x] 최종 우승자가 입력되었던 순서대로 출력될 수 있도록 로직 수정
- 공통
  - [x] 상수를 모아두는 클래스를 사용해서 원시 타입으로 표기되어 있는 부분 수정하기

### 고민해볼 것/메모
- 입/출력 테스트를 어떻게 하면 좋을까? 필요할까?
- 우승자를 판단하는 클래스에서 출력까지 고려해줄 필요는 없어보였다.
- 우선순위 큐를 사용했다보니, 정렬 과정에서 순서가 뒤섞였다. 인덱스를 추가하거나 우선순위 큐를 사용하지 않도록 수정할 수 있을 것 같은데 더 좋은 방법이 있을까?
  - 일단 Car 클래스에 인덱스를 추가하는 것으로 해결할 수는 있는데, 안 쓴다면..?
- 우선순위 큐를 사용할 때, 큐가 비어있지 않음을 확인하는 코드가 필요할까?
- Car 클래스의 `toString()` 메서드에서도 원시 타입은 아니지만, 상수로 볼 수 있는 문자열이 사용된다. `toString()` 메서드는 재정의하는 것만으로도 구현하는 의도가 명확한데, 여기서 사용되는 문자열도 불변 상수를 만들어서 사용해야 할까?
- 인덱스를 위해서 사용되는 원시 타입 변수를 모두 `private static final` 변수로 만드는 것이, 거대한 프로그램을 만드는 경우에는 비효율적이지 않을까? `OutputView` 클래스의 `recordWinner` 메서드에서는 그것을 피하고자 변수 이름에서 의미를 파악할 수 있도록 써놓기는 했는데, 무엇이 좋을지 고민해보자.
- 내가 코드를 작성하고도 혼동되는 부분이 있었다.
  `Application` 클래스의 `main` 메서드에서 `Controller` 타입으로 변수를 생성하고, `Controller` 타입이라면 가져야할 `gameStart()` 메서드를 호출하는데, 어떻게 구체 클래스 `RacingGameController`의 `gameStart()` 메서드인지 알고 사용하는 것일까?
  - 여기서는 동적 메서드 디스패치(Dynamic Method Dispatch) 또는 실행 시간 다형성(Runtime Polymorphism) 메커니즘이 실행되었기 때문이다. 이것은 컴파일 타임이 아닌, 실행 시간에 업캐스팅된 자식 클래스의 재정의된 메서드를 호출한다.
  다시 말하면, 변수의 선언 타입이 아닌 실제 메모리에 할당된 객체 타입에 정의된 메서드를 호출하기 때문이다.
  - 코드를 실행해보고, '이게 웨됌?' 싶었다. 클래스 추상화가 아직 어색하게 다가왔던 것 같다. 좀 더 연습해보면 좋을 듯!