# 2주차 미션 - 자동차 경주 개발 문서

구현할 기능 목록, 참고할 점, 개발에 들어가기 전에 염두할 점, 개발을 진행하면서의 고민이나 메모를 기록하는 문서입니다.

## 구현할 기능들

* 개념일 거라고 예상되는 단어가 처음 등장할 때, `''(따옴표)`로 표시합니다.

- [x] '자동차 경주'를 시작하기
- [x] '경주자' 이름을 형식에 맞춘 입력값으로 받기
- [x] 경주가 이뤄지는 회차 입력 받기
- [x] 경주 진행하기
    - [x] 실행 결과 안내문구 보여주기
    - [x] 회차 당 각 경주자의 '주행' 상태 보여주기
        - [x] 각 경주자는 Randoms를 통한 랜덤값을 기준으로 전진하거나 제자리에 있는다
        - [x] 각 경주자의 주행 상태를 형식에 맞춘 문자열로 보여주기
        - [x] 회차 별 주행 상태를 보여준 뒤 빈 줄을 하나 출력한다(회차 별 내용을 구분하는 용도)
    - [x] 회차가 모두 소요되면 경주는 종료된다.
- [x] 최종 우승자 발표하기
    - [x] 가장 주행거리가 먼 참가자들을 추린다.
    - [x] 추려진 참가자들을 형식에 맞춘 문자열로 보여줄 수 있다.
- [x] 자동차 경주에서 비정상 입력 시(예외가 발생할 시) 종료하기

## 참고사항

### 등장하는 개념에 관한 용어 소개

- 자동차 경주Race: 요구사항의 대표명.
- 경주자Racer: 경주에 참여할 자동차 이름을 경주자라고 부르기로 한다.
- 회차Lap: 시간(회수) 개념을 회차라고 부르기로 한다.
- 주행거리Mileage: 경주자가 경기동안 전진한 주행거리를 말한다.
- 진행상황Progress: 주행 후 특정 순간마다 확인하는 주행상황을 말한다. 게임 전체의 진행상황, 한 회차의 진행상황, 각 레이서 별 진행상황이 있다.

### 패키지 간략 소개

- `game` : 어플리케이션 메인 로직. 요구사항을 처리하기 위한 어플리케이션 전반의 로직을 핸들링하는 클래스가 포함된다.
- `collaborator` : 메인 로직(`game.*`)과 협력하는 객체
- `io` : 데이터가 들어오고 나가는 것과 관련된 클래스/인터페이스가 포함된다. 어플리케이션 전반 공통 기능을 다루는 클래스만이 최상위에 존재할 수 있다. 특정 로직과 결합된 기능은 하위 패키지로 존재한다.
    - `io.views` : 어플리케이션에 특화된 뷰 로직을 담는 클래스가 포함된다.
- `generic` : 어플리케이션 전반에서 사용되는 '단위' 등의 값 객체가 포함된다.

### enums 컨벤션 소개

메시지를 표현하기 위해서 enum 클래스를 사용하고 있다. 아래는 enum을 사용하는 컨벤션 내용이다.

- 특정 클래스의 메시지 클래스는 `(클래스명)Message`라는 이름을 가지고 있다.
- 특정 클래스의 메시지 클래스는 동일 레벨의 `enums` 패키지 안에 있다.
- 특정 클래스에서 메시지 enum을 사용할 때는 `static import`로 생략할 수 있다. 특정 클래스가 아닌 곳에서 타 메시지 enum을 사용할 때는 생략할 수 없다.
- 앱 전역에서 사용되는 `GlobalMessage`는 예외다. 최상위의 enums 패키지에 위치하며, 어떤 클래스 안에서 사용하든지 `static import`를 이용한 enum명 생략을 사용할 수 없다.
- enum 필드는 반드시 `private final`로 사용한다. `get()`이라는 getter를 활용해 메시지를 획득한다.
- enum 클래스를 테스트 할 때에는 `get()`은 테스트하지 않는다. enum 클래스는 편의 기능 공개 메서드가 있는 경우에만 테스트 한다.

## 개발에 들어가기 전에 기억할 사항

- 1주차 때도 고민했지만, 인풋/아웃풋은 더욱 기능을 분리하는 편이 나을 수 있다. 나중에도 계속 쓸 수 있는 코드를 만든다 생각하고 코딩할 것.
- 테스트 하기 쉬운 코드를 만들려면 어떻게 해야하는지 계속 의식적으로 생각할 것.
- 테스트 먼저까진 아니더라도, 가급적이면 테스트 코드 빠르게 추가할 것.
- 한 번에 멋지게 만들려는 생각조차 하지 말 것. 어차피 고치면 되고 고치게 되어있음.
- 커밋 메시지 피드백 받은 것 & 스스로 생각한 대로 좀 더 보기좋게 개선할 것.

## 개발을 시작하고 나서의 고민들 & 메모

### 2023-10-26

- [코드리뷰 하면서 좋았던 MVC 코드](https://github.com/woowacourse-precourse/java-baseball-6/pull/2312#discussion_r1372543018)가
  있었는데, MVC 패턴까진 아니더라도 좋았던 개념 부분(실행 흐름과 객체 상태를 깔끔하게 분리)은 적용할 수 있을지 고민해보자.
- 실행흐름과 상태를 관리할 객체를 분리해야 테스트가 가능하겠다는 생각까진 했었고, 그래서 이번에는 시작부터 분리했는데... 그런데 상태변경만 하는 행위의 경우에는 리턴값이 없어서 검증할 수가 없다. 테스트를 위해서
  리턴값을 넘겨야 하나...? 테스트가 코드 변경에 영향을 주는건 싫은데... 방법이 없을까?

### 2023-10-27

- 개념이 처음 떠오른 순간에 작명을 잘 해야하는 것 같다. Race와 Racer라는 단어를 함께 쓰니까, RaceProgress, RacerProgress 처럼 협력하는 다른 클래스에도 비슷한 단어들이 묻어버린다.
  게다가 의미전달도 잘 안되고... 나도 헷갈려서 오타를 낼 정도다. 후회된다🥲 하지만 이를 통해 작명이 정말 중요하단 사실을 알게 되었다. 일단은 진행하고 리팩토링 할 때 고쳐보도록 하자!

### 2023-10-30

- 협력객체의 뷰 로직을 전부 분리한다면 분리된 클래스들의 패키지는 game 하위에 놓아야 할까, collaborator 하위에 놓아야 할까?
    - game 하위에 놓자 : 사용을 game.RacingGame에서 한다.
    - collaborator 하위에 놓자 : 사용 위치로 보면 game 하위에 놓는게 일견 그럴듯하지만, 결국 game 밑에 collaborator 정보가 들어가게 되는 거니까 패키지를 분리한 의미가 사라진다.
    - io 밑은 어떨까? 지금은 'collaborator -> io'로 호출하고 있지만 'game -> io'로 바뀔 뿐이 되는 것이다. 그러면 collaborator는 더이상 io를 알 필요가 없고,
      game만 중간에서 핸들링 하면 된다. 이게 딱인것 같다.
    - 그런...것 같았는데... 막상 한 메서드를 옮겨보니까 리턴타입에서 import가 추가된다. 즉 의존관계가 엮인다... 이래서 완전히 분리하고 싶으면 DTO를 써주는거구나... 현재는 의존관계가 엮이더라도
      무방하니까 일단 DTO까지 분리하진 말자.
    - 이런 저런 시도를 해보고 있지만 완전히 나눠지지가 않는다... 이건 어떻게 나눌 수 있을까. 무조건 나누는게 좋을까 하는 생각도 든다.

### 2023-10-31

- 어제 DTO를 쓰는 이유같은걸(?) 발견했었는데, 오늘 다른 점 한 가지를 더 느꼈다.
    - 입력받을 값에 제한사항이 있으면 '입력 받고, 변수에 담고, 담은 변수를 검증 메서드에 넘기고, 문제없으면 호출한 쪽으로 변수값을 리턴'의 순서로 예외처리를 진행했다.
    - '입력받고, 변수에 담고'부분과 '담은 변수를 검증메서드에 넘기고' 부분이 마음에 들지 않았다. 입력 받는 부분과 검증에 넘기는 부분이 무조건 두 줄의 분리된 코드로 작성되었기 때문이다.
    - 합치고 싶어서 고민을 하다가, 입력값을 받는(혹은 만드는) 부분(예: RaceView.toRacer())에서 예외처리를 하면 "전달할 입력값을 만듦과 동시에" 예외처리를 할 수 있었다.
    - 그리고 "동시에" 이뤄지는 예외처리 메서드는 입력값이 일정하면 출력값(정확히는 동작)이 일정한... 함수에 가까운.. 즉 static method였다. 그말은, 현재 instance와 무관하게 예외처리가
      가능하다는 의미이기도 하다.
    - 그렇다면, 아예 입력값의 타입 자체를 분리하는 것도 가능하다. 애초에 무관한 동작을 하니까. 하지만 동작은 무관하면서도 "무언가의 입력"값이라는 타입 자체가 "무언가"와의 연관이 있음을 잘 보여주니까.
    - 입력값을 하나의 타입으로 표현, 즉 DTO라는 걸 사용하면, DTO가 해당 입력 동작의 입력타입이란 걸 강하게 표현함과 동시에 필요한 예외처리를 객체 코드 수준으로 묶을 수 있다. 밖에는 예외처리 코드가
      보이지 않으니, 이 책임의 코드 저 책임의 코드를 한번에 혼잡하게 읽지 않아도 되어서 좋다.
- 문자열 보간
    - 1주차 코드리뷰를 받은 것 중에, '+'를 이용한 문자열 보간보다 스트링빌더가 성능이 더 좋으므로 교체하는게 좋다는 리뷰를 받았다. 나는 꼭 그렇지만은 않을 수 있지만, 그래도 (여러명이 함께 개발하고
      있다면)'스트링빌더가 성능이 더
      좋으니까 고치자'고 대화에 비용을 쏟는 것보단 표준을 맞추는게 나을수도 있겠다는 답변을 했었다.
    - 스트링의 '+' 연산이 필요한 경우 StringBuilder로 최적화 되거나 내부 byte[]의 캐싱이 생각보다 잘 되어 있어서 그닥 느리지 않다는 건 알고 있었다.
    - 하지만 '정말로 정말로 StringBuilder(또는 Buffer)가 정말 String의 '+' 연산보다 빠를까? 빠르다면 얼마나 빠를까?'가 궁금해졌다.
    - 랜덤으로 생성한 RacerProgress 객체 2천만개를 가지고 테스트해보았다. 테스트 진행 중에 다른 작업은 최소한으로 억제했다.
        - 시험1(문자열의 문자 전부가 아스키코드에 해당하는 경우)
            - '+' 연산: 평균 3천 ms가 걸렸다.
            - 빌더 연산: 평균 5~6 ms가 걸렸다.
        - 시험2(유니코드가 포함된 문자열과 아스키 문자의 조합인 경우)
            - '+' 연산: 평균 3~4천 ms가 걸렸다.(오히려 시험1보다 빠를 때도 있다. 유니코드 문자에 영향을 전혀 받지 않는 것 같다)
            - 빌더 연산: 평균 8~9천 ms가 걸렸다. StringBuffer를 써도 성능은 크게 달라지지 않는다.
    - 배운 사실 : 첫번째. 정말 크게 동적으로 변하는 문자열이 아니라면 빌더 연산은 별 효과가 없고 오히려 역효과가 있을 수 있다. 두번째. 혹시 모르겠다, 아리까리하다 싶으면 테스트를 해보면 명확하다.
    - 추가 : 빌더 연산의 마지막 부분에서 toString()을 제거하면 조금 빨라진다(1000ms 정도). 근데 결국 String으로 쓰기 위해서 빌더연산도 하는건데, toString()을 빼는게 맞나 싶기도
      하다.

### 2023-11-01

- 갑자기 드는 생각인데, 클래스 상수와 enum의 차이는, enum은 공통된 행위와 클래스 단위로 묶여있다는 정도의 차이인 것 같다. 상수 만의 행위를 제공할 필요가 없거나 한데 묶일 여러 상수가 없다면, 클래스
  상수로 기재해도 무방할 것 같다(enum보다 클래스 상수가 좋다기 보단, 말 그대로 무방할 것 같다).
    - 추가: enum으로 메시지를 사용하니까 테스트 시에 발생하는 예외 메시지까지 검증할 수 있다. 좋은 것 같다.
- Application에 있는 연관관계를 밖으로 꺼내고 싶은데, 이 레퍼런스들이 스태틱해야 하는지 아닌지 헷갈린다.. 그리고 실행 코드 내부에서 초기화 되는 객체들은...?
- 자다가 든 생각인데, 뷰에 대한 생각을 조금 남겨본다.
    - 데이터를 받아서 뷰에서 조작하는 부분에 코드가 조금 복잡한가 하는 생각이 들었다. 정확히는 다층적인 데이터를 뷰에 전달하고, 뷰에서 복잡하게 꺼내쓰는게 조금 뭔가 거리껴졌었다.
    - 그렇다면, 데이터를 조회하는 코드를 실행할 때 인수로 '뷰 로직'을 전달하고, 협력객체는 전달받은 '뷰 로직'에 조회된 데이터를 꽂아만 주고 다시 돌려주면 어떨까?
    - 그럼 만약 코드를 짠다면 뷰 로직은 어디에 존재하게 될까?
- 테스트 코드의 중복을 제거하기 위해 상속 기능을 사용했다.
    - Java를 사용중이라면 사실 당연하게 되는게 상속인데, 테스트에서 사용할 수도 있다는 건 약간 생각의 전환이 필요했던 것 같다.
    - 제공되는 라이브러리를 보고 중복 제거의 영감을 얻었다. 다른 코드를 많이 봐야겠다는 생각이 더욱 든다.
- '연관관계'만 클래스로 추출하면 어떨까?
    - 모든 객체 생성 책임을 가지진 않고(예를 들어 값객체를 new 하는 것은 실행 흐름 안에서 알아서하도록 손대지 않는거), 딱 어플리케이션 실행에 사용되는 '연관관계'만 책임을 지는 거다.
    - 다시 쉽게 말하면, 인스턴스 필드로 정의된 레퍼런스 변수만 연관관계에서 책임을 지면 되는 거다... 괜찮은 것 같은데?...
    - 그러면 일단 첫째로, 보기 싫은 연관관계 정의 코드가 어플리케이션 코드에서 사라진다.
    - 둘째로, 연관관계만 갈아끼우면 얼마든지 테스트 객체로 바꿔넣을 수 있다. 이게 좀 컸던게, 테스트에서 사용할 값 객체 같은 것들을 계속 만들어주는게 꽤나 귀찮은 작업이었다.
    - 근데 생각해보니까, 값객체는 연관관계랑은 무관하게 생성되는 객체들이네.
    - 어렵다... 하지만 일단 언젠가 써먹을 수 있는 기분이 든다... 아이디어로 간직해두자.
